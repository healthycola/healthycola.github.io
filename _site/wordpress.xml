<?xml version="1.0" encoding="UTF-8"?>
<!--
 This is a WordPress eXtended RSS file generated by WordPress as an export of your site.
 It contains information about your site's posts, pages, comments, categories, and other content.
 You may use this file to transfer that content from one site to another.
 This file is not intended to serve as a complete backup of your site.

 To import this information into a WordPress site follow these steps:
 1. Log in to that site as an administrator.
 2. Go to Tools: Import in the WordPress admin panel.
 3. Install the "WordPress" importer from the list.
 4. Activate & Run Importer.
 5. Upload this file using the form provided on that page.
 6. You will first be asked to map the authors in this export file to users
    on the site. For each author, you may choose to map to an
    existing user on the site or to create a new user.
 7. WordPress will then import each of the posts, pages, comments, categories, etc.
    contained in this file into your site.
-->
<!-- generator="WordPress.com" created="2014-07-30 17:51"-->
<rss version="2.0" xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:wp="http://wordpress.org/export/1.2/">
  <channel>
<title>Code, Bagels and Gibberish</title>
<link>http://codeandbagels.wordpress.com</link>
<description>but mainly gibberish</description>
<pubDate>Wed, 30 Jul 2014 17:51:52 +0000</pubDate>
<language>en</language>
<wp:wxr_version>1.2</wp:wxr_version>
<wp:base_site_url>http://wordpress.com/</wp:base_site_url>
<wp:base_blog_url>http://codeandbagels.wordpress.com</wp:base_blog_url>
<wp:wp_author>
  <wp:author_login>aamirsbored</wp:author_login>
  <wp:author_email>lordwizards@gmail.com</wp:author_email>
  <wp:author_display_name><![CDATA[healthycola]]></wp:author_display_name>
  <wp:author_first_name><![CDATA[]]></wp:author_first_name>
  <wp:author_last_name><![CDATA[]]></wp:author_last_name>
</wp:wp_author>
<wp:category>
  <wp:term_id>2426</wp:term_id>
  <wp:category_nicename>c</wp:category_nicename>
  <wp:category_parent/>
  <wp:cat_name><![CDATA[C++]]></wp:cat_name>
</wp:category>
<wp:category>
  <wp:term_id>5189</wp:term_id>
  <wp:category_nicename>fitness</wp:category_nicename>
  <wp:category_parent/>
  <wp:cat_name><![CDATA[fitness]]></wp:cat_name>
</wp:category>
<wp:category>
  <wp:term_id>27923</wp:term_id>
  <wp:category_nicename>powerlifting</wp:category_nicename>
  <wp:category_parent/>
  <wp:cat_name><![CDATA[powerlifting]]></wp:cat_name>
</wp:category>
<wp:category>
  <wp:term_id>2470772</wp:term_id>
  <wp:category_nicename>trie</wp:category_nicename>
  <wp:category_parent/>
  <wp:cat_name><![CDATA[Trie]]></wp:cat_name>
</wp:category>
<wp:category>
  <wp:term_id>1</wp:term_id>
  <wp:category_nicename>uncategorized</wp:category_nicename>
  <wp:category_parent/>
  <wp:cat_name><![CDATA[Uncategorized]]></wp:cat_name>
</wp:category>
<wp:category>
  <wp:term_id>15908</wp:term_id>
  <wp:category_nicename>weightlifting</wp:category_nicename>
  <wp:category_parent/>
  <wp:cat_name><![CDATA[weightlifting]]></wp:cat_name>
</wp:category>
<wp:tag>
  <wp:term_id>18127</wp:term_id>
  <wp:tag_slug>algorithm</wp:tag_slug>
  <wp:tag_name><![CDATA[algorithm]]></wp:tag_name>
</wp:tag>
<wp:tag>
  <wp:term_id>2426</wp:term_id>
  <wp:tag_slug>c</wp:tag_slug>
  <wp:tag_name><![CDATA[C++]]></wp:tag_name>
</wp:tag>
<wp:tag>
  <wp:term_id>153304</wp:term_id>
  <wp:tag_slug>encoding</wp:tag_slug>
  <wp:tag_name><![CDATA[encoding]]></wp:tag_name>
</wp:tag>
<wp:tag>
  <wp:term_id>2443655</wp:term_id>
  <wp:tag_slug>huffman</wp:tag_slug>
  <wp:tag_name><![CDATA[huffman]]></wp:tag_name>
</wp:tag>
<wp:tag>
  <wp:term_id>24361</wp:term_id>
  <wp:tag_slug>practice</wp:tag_slug>
  <wp:tag_name><![CDATA[practice]]></wp:tag_name>
</wp:tag>
<generator>http://wordpress.com/</generator>
<image>
		<url>https://s2.wp.com/i/buttonw-com.png</url>
		<title>Code, Bagels and Gibberish</title>
		<link>http://codeandbagels.wordpress.com</link>
	</image>
	<item>
  <title>About</title>
  <link>http://codeandbagels.wordpress.com/about/</link>
  <pubDate>Fri, 11 Jul 2014 06:55:51 +0000</pubDate>
  <dc:creator>aamirsbored</dc:creator>
  <guid isPermaLink="false">http://codeandbagels.wordpress.com/?page_id=1</guid>
  <description/>
  <content:encoded><![CDATA[This is an example of a page. Unlike posts, which are displayed on your blog’s front page in the order they’re published, pages are better suited for more timeless content that you want to be easily accessible, like your About or Contact information. Click the Edit link to make changes to this page or <a title="Direct link to Add New in the Admin Dashboard" href="/wp-admin/post-new.php?post_type=page">add another page</a>.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>1</wp:post_id>
  <wp:post_date>2014-07-11 06:55:51</wp:post_date>
  <wp:post_date_gmt>2014-07-11 06:55:51</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>about</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>page</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <wp:postmeta>
    <wp:meta_key>_wp_page_template</wp:meta_key>
    <wp:meta_value><![CDATA[default]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Vector vs. Arrays</title>
  <link>http://codeandbagels.wordpress.com/2014/07/11/vector-vs-arrays/</link>
  <pubDate>Fri, 11 Jul 2014 07:16:19 +0000</pubDate>
  <dc:creator>aamirsbored</dc:creator>
  <guid isPermaLink="false">http://codeandbagels.wordpress.com/2014/07/11/vector-vs-arrays/</guid>
  <description/>
  <content:encoded><![CDATA[<p>There aren't a whole lot of differences between Vectors and Arrays internally (i.e. in terms of performance). Vectors use an array structure internally but have additional functions to manage it. Some advantages of a vector are as follows:</p>
<ul>
<li>You can dynamically allocate vectors without knowing the exact size at the time of conception. This means that handling vectors will be safer in the long run. You need not be extra careful to exceed the boundaries of a vector. Vectors require more space however. If you want to add to a vector, and the vector is at capacity, it will double its capacity and copy all the contents. This will increase memory usage but improve flexibility</li>
	<li>Vectors have additional functionality such as <code>size</code> and <code>capacity</code> which are very useful.</li>
	<li>Here is a great <a href="http://stackoverflow.com/questions/6462985/c-stl-vector-vs-array-in-the-real-world">response</a> I found on StackOverflow to this:


<blockquote>One of the best reasons to use a vector as opposed to an array is the RAII idiom. Basically, in order for c++ code to be exception-safe, any dynamically allocated memory or other resources should be encapsulated within objects. These objects should have destructors that free these resources.

When an exception goes unhandled, the ONLY things that are gaurenteed to be called are the destructors of objects on the stack. If you dynamically allocate memory outside of an object, and an uncaught exception is thrown somewhere before it is deleted, you have a memory leak.

It's also a nice way to avoid having to remember to use delete.</blockquote>

</li>

</ul>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>2</wp:post_id>
  <wp:post_date>2014-07-11 07:16:19</wp:post_date>
  <wp:post_date_gmt>2014-07-11 07:16:19</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>vector-vs-arrays</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Challenge 1: Accepting console input</title>
  <link>http://codeandbagels.wordpress.com/2014/07/11/challenge-1-accepting-console-input/</link>
  <pubDate>Fri, 11 Jul 2014 09:37:42 +0000</pubDate>
  <dc:creator>aamirsbored</dc:creator>
  <guid isPermaLink="false">http://codeandbagels.wordpress.com/2014/07/11/challenge-1-accepting-console-input/</guid>
  <description/>
  <content:encoded><![CDATA[Lets read in strings. we will give n the number of strings then the strings.
<blockquote>Example:
<code>5
Huey
Dewey
Louie
Donald
Scrooge</code></blockquote>
Seemed like a fairly simple first challenge on my road to recovery back to C++. Here is my first attempt:
[code language="cpp"]#include &lt;iostream&gt;
using namespace std;
int main(int argc, const char * argv[])
{
int NumberOfStrings = 0;
cin &lt;&lt; NumberOfStrings;
string* AllStrings = new string[NumberOfStrings];
for (int i = 0; i &lt; AllStrings[i];
cout &lt;&lt; &quot;The strings inputted were:\n&quot;;
for (int i = 0; i &lt; NumberOfStrings; i++)
cout &lt;&lt; AllStrings[i] + &quot;\n&quot;;
delete[] AllStrings;
return 0;
}
[/code]
Although this is okay, especially for the example in question, it is not really the best solution. First of all it uses arrays, which are looked down upon for scalability. Secondly, I need to remember to delete the array to prevent memory leaks. Second of all, <code>cin</code> considers spaces as end of lines, which is not good for more complex phrases such as:
<blockquote><code>Hello how are you?
I'm fine thanks!
And yourself?</code></blockquote>
Here is a more revised version of the same program:
[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int main(int argc, const char * argv[])
{
// Vector is a more powerful data structure
vector myStrings;
int n = 0;
string temp;
getline(cin, temp);
n = atoi(&amp;temp[0]);
//cin.ignore(); //needed to clear the buffer it seems.
for (int i = 0; i &lt; n; ++i)
{
getline(cin, temp);
myStrings.push_back(temp);
}
cout &lt;&lt; &quot;The strings inputted were: \n&quot;;
for (vector::iterator iter = myStrings.begin(); iter != myStrings.end(); ++iter)
{
cout &lt;&lt; *iter + &quot;\n&quot;;
}
}
[/code]
The main changes include the usage of vectors which are more scalable and the use of getline to get the strings which include spaces and such. This solution seems more elegant.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>4</wp:post_id>
  <wp:post_date>2014-07-11 09:37:42</wp:post_date>
  <wp:post_date_gmt>2014-07-11 09:37:42</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>challenge-1-accepting-console-input</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="c"><![CDATA[C++]]></category>
  <category domain="post_tag" nicename="practice"><![CDATA[practice]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Simple BlackJackChecker</title>
  <link>http://codeandbagels.wordpress.com/2014/07/12/11/</link>
  <pubDate>Sat, 12 Jul 2014 09:59:27 +0000</pubDate>
  <dc:creator>aamirsbored</dc:creator>
  <guid isPermaLink="false">http://codeandbagels.wordpress.com/?p=11</guid>
  <description/>
  <content:encoded><![CDATA[Wanted to add something very quick before heading to bed. I'm going to edit this post when I wake up. Here's my first take on <a href="http://www.reddit.com/r/dailyprogrammer/comments/29zut0/772014_challenge_170_easy_blackjack_checker/" title="Reddit's simple blackjack checker">Reddit's simple blackjack checker</a>. Seems to work, and I think it's fairly elegant, tbh, but I'll have a better look when it's not 6 in the morning :).

Edit: I was reading the code again today. Some of the things I would change are:
<ul>
	<li>Spit the work into input phase and output phase. In input phase, simply store the strings. I feel like that's probably good programming practice.</li>
	<li>Reduce the number of lines in main, although there are that many. Split the different areas into functions.</li>
	<li>Add more objected orientedness to make this more tidy. It's a little bit messy right now.</li>
</ul>

<!--more-->



[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

struct Player
{
    string Name = &quot;&quot;;
    int currentTotal = 0;
    int bestTotal = 0;
    int Aces = 0;
    bool folded = false;
    int NumberOfCards = 0;
    void AddValue(int val)
    {
        if (val == 1)
            Aces++;
        else
            currentTotal += val;
        
        bestTotal = getBestTotal();
        if (bestTotal &gt; 21)
            folded = true;
        NumberOfCards++;
    }
    int getBestTotal()
    {
        int tempTotal = currentTotal;
        int tempAces = Aces;
        if (tempAces &gt; 1)
        {
            //The other aces need to be 1s to get the best value so
            tempTotal += (tempAces - 1);
            tempAces = 1;
        }
        if ( tempTotal + tempAces*11 &lt;= 21)
            return tempTotal + tempAces * 11;
        else
            return tempTotal + tempAces;
    }
    
};

int ConvertCardToInt(string Card)
{
    int output = 0;
    if (Card == &quot;Ace&quot;){
        output = 1;
    }
    else if (Card == &quot;King&quot;){
        output = 10;
    }
    else if (Card == &quot;Queen&quot;){
        output = 10;
    }
    else if (Card == &quot;Jack&quot;){
        output = 10;
    }
    else if (Card == &quot;Ten&quot;){
        output = 10;
    }
    else if (Card == &quot;Nine&quot;){
        output = 9;
    }
    else if (Card == &quot;Eight&quot;){
        output = 8;
    }
    else if (Card == &quot;Seven&quot;){
        output = 7;
    }
    else if (Card == &quot;Six&quot;){
        output = 6;
    }
    else if (Card == &quot;Five&quot;){
        output = 5;
    }
    else if (Card == &quot;Four&quot;){
        output = 4;
    }
    else if (Card == &quot;Three&quot;){
        output = 3;
    }
    else if (Card == &quot;Two&quot;){
        output = 2;
    }
    else
    {
        output = 0;
    }
    return output;
}


vector&lt;string&gt; wordCreater(string input)
{
    vector&lt;string&gt; output;
    // Let's get the name out of the way first
    size_t currentStartPos = input.find_first_of(':');
    string temp = input.substr(0, currentStartPos);
    output.push_back(temp);
    size_t increaser = currentStartPos;
    do
    {
        currentStartPos = increaser + 2;    //Assuming there's a space after the delimiter
        increaser = input.find_first_of(',', currentStartPos);
        temp = input.substr(currentStartPos, increaser - currentStartPos);
        output.push_back(temp);
    } while (increaser != string::npos);
    return output;
}

string getCardVal(string input)
{
    //We know the first word is the card value, so just get that
    size_t FirstSpacePosition = input.find_first_of(' ');
    return input.substr(0, FirstSpacePosition);
}

template &lt;typename T&gt;
void deletePtr(T* const ptr)
{
    delete ptr;
}


bool comparePlayers(Player* i, Player* j)
{
    if (i-&gt;folded &amp;&amp; j-&gt;folded)
        return true; //doesn't even matter
    
    
    if (i-&gt;folded &amp;&amp; !j-&gt;folded)
    {
        return true;
    }
    else if (!i-&gt;folded &amp;&amp; j-&gt;folded)
    {
        return false;
    }
    //Check for 5 card trick
    else if (i-&gt;NumberOfCards &gt;= 5)
    {
        return false;
    }
    else if (j-&gt;NumberOfCards &gt;= 5)
    {
        return true;
    }
    // both are either not folded
    else if (i-&gt;bestTotal &lt; j-&gt;bestTotal)
        return true;
    else
        return false;
}
int main(int argc, const char** argv)
{
    vector&lt;Player*&gt; Players;
    // Get the number of
    int NumberOfPlayers = 0;
    string temp;
    getline(cin, temp);
    
    NumberOfPlayers = atoi(&amp;temp[0]);
    for (int i; i &lt; NumberOfPlayers; i++)
    {
        getline(cin, temp);
        Player* player = new Player();
        vector&lt;string&gt; tokens = wordCreater(temp);
        player-&gt;Name = tokens[0];
        
        for (vector&lt;string&gt;::iterator iter = tokens.begin() + 1; iter != tokens.end(); iter++){
            string cardValue = getCardVal(*iter);
            player-&gt;AddValue(ConvertCardToInt(cardValue));
        }
        Players.push_back(player);
    }
    sort(Players.begin(), Players.end(), comparePlayers);
    
    //Winner
    if (!(*(Players.end() - 1))-&gt;folded)
    {
        string trick = ((*(Players.end() - 1))-&gt;NumberOfCards &gt;= 5 ) ? &quot; with a 5-card trick!&quot; : &quot;!&quot;;
        cout &lt;&lt; &quot;\n&quot; + (*(Players.end() - 1))-&gt;Name + &quot; has won&quot; + trick;
    }
    else
        printf(&quot;\nNo one won!&quot;);
    
    //clean up
    for_each(Players.begin(), Players.end(), deletePtr&lt;Player&gt;);
    
    return 0;
}[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>11</wp:post_id>
  <wp:post_date>2014-07-12 09:59:27</wp:post_date>
  <wp:post_date_gmt>2014-07-12 09:59:27</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>11</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Simple RummyChecker</title>
  <link>http://codeandbagels.wordpress.com/2014/07/14/simple-rummychecker/</link>
  <pubDate>Mon, 14 Jul 2014 02:29:48 +0000</pubDate>
  <dc:creator>aamirsbored</dc:creator>
  <guid isPermaLink="false">http://codeandbagels.wordpress.com/?p=19</guid>
  <description/>
  <content:encoded><![CDATA[This is a build up on the BlackJack Checker. The Rummy Checker challenge is also from Reddit and can be found <a href="http://www.reddit.com/r/dailyprogrammer/comments/2a9u0a/792014_challenge_170_intermediate_rummy_checker/">here</a>. I think it's more organized than the blackjack checker and less hacky (except for the Run checker function - this function is soooo messy. I need to fix it, urgh).

Major things I'm happy about:
<ul>
	<li>Simple tokenizer - It's just good to have this code. I think it's reusable.</li>
	<li>Decent organization - A Card class and a Hand class was created. I think the organization is decent, not amazing, but it's getting there.</li>
</ul>
Areas I need to improve on:
<ul>
	<li>Rummy Run Detector - At the moment it's really brute-forcy. Gotta think of a better idea to go about it.</li>
	<li>Separation - Could use better separation between input and output areas of the program, just for good coding practice.</li>
</ul>
<!--more-->


[code language="cpp"]
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

using namespace std;
int RunLength = 3;
int SetLength = 3;

enum Suite
{
    Spades, Hearts, Clubs, Diamonds, Unknown
};

static const vector&lt;string&gt; tokenizeStrings(string input, string delimiter, int NumberOfSpacesAfterDelimiter)
{
    vector&lt;string&gt; output;
    size_t start;
    size_t found = -1 - NumberOfSpacesAfterDelimiter;  //Two because of spaces after delimiter
    string temp;
    do {
        start = found + 1 + NumberOfSpacesAfterDelimiter;  //Two because of spaces
        found = input.find_first_of(delimiter, start);
        temp = input.substr(start, found - start);
        output.push_back(temp);
    } while(found != string::npos);
    return output;
}

struct Card
{
    Suite m_suite;
    int m_value;

    static const string CardValues[13];
    static const string CardSuits[4];
    static const int ConvertCardValueToInt(string Card)
    {
        int output = 0;
        if (Card == &quot;ace&quot;){
            output = 1;
        }
        else if (Card == &quot;king&quot;){
            output = 13;
        }
        else if (Card == &quot;queen&quot;){
            output = 12;
        }
        else if (Card == &quot;jack&quot;){
            output = 11;
        }
        else if (Card == &quot;ten&quot;){
            output = 10;
        }
        else if (Card == &quot;nine&quot;){
            output = 9;
        }
        else if (Card == &quot;eight&quot;){
            output = 8;
        }
        else if (Card == &quot;seven&quot;){
            output = 7;
        }
        else if (Card == &quot;six&quot;){
            output = 6;
        }
        else if (Card == &quot;five&quot;){
            output = 5;
        }
        else if (Card == &quot;four&quot;){
            output = 4;
        }
        else if (Card == &quot;three&quot;){
            output = 3;
        }
        else if (Card == &quot;two&quot;){
            output = 2;
        }
        else
        {
            output = 0;
        }
        return output;
    }

    static const string ConvertIntToCardValue(int Val)
    {
        if (Val &gt; 0 &amp;&amp; Val &lt;= 13)
            return CardValues[Val - 1];

        return &quot;&quot;;
    }

    static const Suite ConvertCardStringToSuite(string input)
    {
        Suite s = Unknown;
        if (input == &quot;spades&quot;)
            s = Spades;
        else if (input == &quot;hearts&quot;)
            s = Hearts;
        else if (input == &quot;clubs&quot;)
            s = Clubs;
        else if (input == &quot;diamonds&quot;)
            s = Diamonds;

        return s;
    }

    static const string ConvertCardSuitToString(Suite input)
    {
        if (input &gt;= 0 &amp;&amp; input &lt;= 3)
            return CardSuits[input];

        return &quot;&quot;;
    }

    Card(string CardInput)
    {
        //Accepts inputs such as Ace of Diamonds
        vector&lt;string&gt; temp = tokenizeStrings(CardInput, &quot; &quot;, 0);
        m_value = ConvertCardValueToInt(temp[0]);
        m_suite = ConvertCardStringToSuite(temp[2]);
    }
};

const string Card::CardValues[13] = { &quot;ace&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;, &quot;jack&quot;, &quot;queen&quot;, &quot;king&quot; };
const string Card::CardSuits[4] = { &quot;spades&quot;, &quot;hearts&quot;, &quot;clubs&quot;, &quot;diamonds&quot; };

template &lt;class T&gt;
void deletePtr(T* ptr)
{
    delete ptr;
}

struct Hand
{
    vector&lt;Card*&gt; m_hand;
    void AddCard(Card *card)
    {
        m_hand.push_back(card);
    }

    void cleanUp()
    {
        for_each(m_hand.begin(), m_hand.end(), deletePtr&lt;Card&gt;);
    }

    static bool sorter(Card* i, Card* j)
    {
        if (i-&gt;m_suite != j-&gt;m_suite)
            return (int)(i-&gt;m_suite) &lt; (int)(j-&gt;m_suite);
        else
            return i-&gt;m_value &lt; j-&gt;m_value;
    }

    void sortHand()
    {
        sort(m_hand.begin(), m_hand.end(), Hand::sorter);
    }

    Card* CheckForSet(Card _card)
    {
        int NewSet = _card.m_value;
        int NumberOfCardsForSet = 1;
        for (vector&lt;Card*&gt;::iterator card = m_hand.begin(); card != m_hand.end(); card++)
        {
            if ((*card)-&gt;m_value == NewSet)
                NumberOfCardsForSet++;
        }
        if (NumberOfCardsForSet &gt;= SetLength)
        {
            // Means we have a set
            for (vector&lt;Card*&gt;::iterator card = m_hand.begin(); card != m_hand.end(); card++)
            {
                if ((*card)-&gt;m_value != NewSet)
                    return *card;
            }
        }
        return nullptr;
    }

    Card* CheckForRun(Card _card)
    {
        //Messy as hell
        vector&lt;Card*&gt; Run;
        bool isRun = false;
        for (vector&lt;Card*&gt;::iterator card = m_hand.begin(); card != m_hand.end(); card++)
        {
            isRun = false;
            if ((*card)-&gt;m_suite != _card.m_suite)
            {
                continue;
            }

            Run.clear();
            Run.push_back(&amp;_card);
            for (vector&lt;Card*&gt;::iterator card_set = card; card_set != m_hand.end(); card_set++)
            {
                if (Run.size() &gt;= RunLength || (*card_set)-&gt;m_suite != _card.m_suite)
                    break;
                Run.push_back((*card_set));
            }

            if (Run.size() &lt; RunLength)
            {
                //No runs possible
                isRun = false;
                break;
            }

            sort(Run.begin(), Run.end(), sorter);
            if ((*(Run.end()-1))-&gt;m_value - (*(Run.begin()))-&gt;m_value == RunLength - 1)
                isRun = true;

            //Found a Run?
            if (isRun)
            {
                vector&lt;Card*&gt;::iterator cardReturn = m_hand.begin();
                for (; cardReturn != m_hand.end(); cardReturn++)
                {
                    bool foundCardReturn = true;
                    for (vector&lt;Card*&gt;::iterator set_check = Run.begin(); set_check != Run.end() - 1; set_check++)
                    {
                        //CHeck if current cardReturn is in the Run.
                        if (*set_check == &amp;_card)
                            continue;

                        if (*cardReturn == *set_check)
                        {
                            // The card we want to return can't be in the set
                            foundCardReturn = false;
                            break;
                        }
                    }
                    if (foundCardReturn)
                    {
                        return *cardReturn;
                    }
                }
                break;
            }
        }

        return nullptr;
    }
};

void outputWin(Card* card)
{
    if (card)
    {
        cout &lt;&lt; &quot;Swap the new card with &quot; &lt;&lt; Card::ConvertIntToCardValue(card-&gt;m_value) &lt;&lt; &quot; of &quot; &lt;&lt; Card::ConvertCardSuitToString(card-&gt;m_suite) &lt;&lt; &quot; to win!\n&quot;;
    }
    else
    {
        printf(&quot;No possible winning hand.\n&quot;);
    }

}

int main(int argc, char** argv)
{
    //string sampleString = &quot;Two of Diamonds, Three of Diamonds, Four of Diamonds, Seven of Diamonds, Seven of Clubs, Seven of Hearts, Jack of Hearts&quot;;
    //string newCard = &quot;Five of Diamonds&quot;;

    string sampleString, newCard;
    cout &lt;&lt; &quot;What is the initial hand?: &quot;;
    getline(cin, sampleString);
    cout &lt;&lt; &quot;What is the added hand?: &quot;;
    getline(cin, newCard);

    Hand myHand;
    //transform everything to lower case
    transform(sampleString.begin(), sampleString.end(), sampleString.begin(), ::tolower);
    transform(newCard.begin(), newCard.end(), newCard.begin(), ::tolower);
    vector&lt;string&gt; hand = tokenizeStrings(sampleString, &quot;,:&quot;, 1);

    // For each of the cards, we need to create cards out of them
    for (vector&lt;string&gt;::iterator _card = hand.begin(); _card != hand.end(); _card++)
        myHand.AddCard(new Card(*_card));
    myHand.sortHand();

    Card* swappableCard = new Card(newCard);

    cout &lt;&lt; &quot;Checking for a run with length &quot; &lt;&lt; RunLength &lt;&lt; &quot;\n&quot;;
    Card* swappedCard = myHand.CheckForRun(*swappableCard);
    outputWin(swappedCard);

    cout &lt;&lt; &quot;Checking for a set with length &quot; &lt;&lt; SetLength &lt;&lt; &quot;\n&quot;;
    swappedCard = myHand.CheckForSet(*swappableCard);
    outputWin(swappedCard);

    RunLength = 4;
    cout &lt;&lt; &quot;Checking for a run with length &quot; &lt;&lt; RunLength &lt;&lt; &quot;\n&quot;;
    swappedCard = myHand.CheckForRun(*swappableCard);
    outputWin(swappedCard);

    SetLength = 4;
    cout &lt;&lt; &quot;Checking for a set with length &quot; &lt;&lt; SetLength &lt;&lt; &quot;\n&quot;;
    swappedCard = myHand.CheckForSet(*swappableCard);
    outputWin(swappedCard);

    //Clean up
    delete swappableCard;
    myHand.cleanUp();

    return 0;
}
[/code]

Here's a sample of an input and output:
<pre>What is the initial hand?: Two of Diamonds, Three of Diamonds, Four of Diamonds, Seven of Diamonds, Seven of Clubs, Seven of Hearts, Jack of Hearts
What is the added hand?: Five of Diamonds
Checking for a run with length 3
Swap the new card with seven of hearts to win!
Checking for a set with length 3
No possible winning hand.
Checking for a run with length 4
Swap the new card with seven of hearts to win!
Checking for a set with length 4
No possible winning hand.
</pre>
<span style="text-decoration:underline;"><strong>A brief explanation on the two checker methods</strong></span>

<em>Set Checker:</em>
Simply go through the hand and count the number of cards with the same value as the new card. If it exceeds 3 of 4, then you have a set. Then just go through the hand once more and swap with the first card that isn't the same value as the new card.

<em>Run Checker:
</em>This code is significantly more messy. Let's see. Go through each card in the (sorted) hand until you get to the same suit as the new card. (Aside: the sort method that I've implemented, sorts the hands in terms of values grouped with their individual suits). Then, depending on if we're checking for a 3 card or 4 card run, we create a temporary second set called a Run (which is essentially a vector of cards).
We insert the new card in, and then insert the next 2 to 3 cards in depending on the length of the run we're interested in. When we're doing this, and we encounter a card with a different suit than our new card, we know that a run isn't possible since we've hit a new suit in a sorted hand, so break out of the function. If we are successful in adding the right number of cards, we sort this mini hand. Then we subtract the largest value from the smallest value, and the result should be the length of the run we are interested in minus 1. So for instance, if we are interested in a run of 4 cards, and we have 3, 4, 5, 6 of the same suit, then 6 - 3 would give us 3. Now if this is the case, then we have successfully found a run!
To find a card we can remove from the hand, I use the brute force method. Which means going through the hand once again and as soon as I hit a card which is not in the mini-hand, I can discard that card.
<em>Clearly this method can be improved upon....</em>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>19</wp:post_id>
  <wp:post_date>2014-07-14 02:29:48</wp:post_date>
  <wp:post_date_gmt>2014-07-14 02:29:48</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>simple-rummychecker</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>2D Matrix Rotator</title>
  <link>http://codeandbagels.wordpress.com/2014/07/16/2d-matrix-rotator/</link>
  <pubDate>Wed, 16 Jul 2014 17:37:58 +0000</pubDate>
  <dc:creator>aamirsbored</dc:creator>
  <guid isPermaLink="false">http://codeandbagels.wordpress.com/?p=27</guid>
  <description/>
  <content:encoded><![CDATA[Simple challenge was <a href="http://www.reddit.com/r/dailyprogrammer/comments/29i9jw/6302014_challenge_169_easy_90_degree_2d_array/">posted</a> up on reddit.

There was a really simple solution to it which would perform the task with O(n<sup>2</sup>) space and O(n<sup>2</sup>) time. It would involve creating a new array with the same dimensions as the original matrix, and copying the values into their new spots.

I wanted to do better than this solution and thought of an onion-method to do it. It would include starting with the outside layer of the matrix, and switching the numbers with their new spots for the four sides. For instance, if the following was the matrix:
<code>
|  1  |  2  |  3  |  4  |
|  5  |  6  |  7  |  8  |
|  9  |  10 |  11 |  12 |
|  13 |  14 |  15 |  16 |
</code>
In the first layer, for the first iteration, 1 would move to 4s position, 4 would move to 16, 16 would move to 13s position, and 13 would move to 1s position. Iterating through all n - 1 numbers of the layer, (i.e. 1 to 3), the outer layer would have been rotated. Moving down inwards in similar fashion will have switched the entire matrix.
<!--more-->


Let's get to the code:
[code language="cpp"]
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;math.h&amp;gt;
using namespace std;


// Slightly modified from the original tokenizeString in RummyChecker. This version converts the strings directly into integers
static const vector&amp;lt;int&amp;gt; tokenizeStrings(string input, string delimiter, int NumberOfSpacesAfterDelimiter)
{
    vector&amp;lt;int&amp;gt; output;
    size_t start;
    size_t found = -1 - NumberOfSpacesAfterDelimiter;  //Two because of spaces after delimiter
    string temp;
    do {
        start = found + 1 + NumberOfSpacesAfterDelimiter;  //Two because of spaces
        found = input.find_first_of(delimiter, start);
        temp = input.substr(start, found - start);
        output.push_back(atoi(&amp;amp;temp[0]));
    } while(found != string::npos);
    return output;
}

void printMatrix(int* matrix, int N)
{
    cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
    for (int r = 0; r &amp;lt; N; r++)
    {
        for (int c = 0; c &amp;lt; N; c++)
        {
            cout &amp;lt;&amp;lt; matrix[r*N + c] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        }
        cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
    }
}
void rotateMatrix(int* matrix, int N)
{
    //Work from outside, and rotate inwards
    double layerLimit = (double)N/2.0;
    for (int layer = 1; layer &amp;lt;= ceil(layerLimit); layer++)
    {
        int tempSource, tempTarget, tempIndex1, tempIndex2;
        for (int i = 0; i &amp;lt; N - 2*layer + 1; i++)
        {
            tempIndex1 = (layer - 1)*N - 1 + layer + i;
            tempIndex2 = (layer - 1)*N + N*(i + 1) -layer;
            tempTarget = matrix[tempIndex2];
            matrix[tempIndex2] = matrix[tempIndex1];
            tempSource = tempTarget;
            tempIndex2 = N*N - (layer - 1)*N - layer - i;
            tempTarget = matrix[tempIndex2];
            matrix[tempIndex2] = tempSource;
            tempSource = tempTarget;
            tempIndex2 = N*(N - i - 1) - (layer - 1)*N + layer - 1;
            tempTarget = matrix[tempIndex2];
            matrix[tempIndex2] = tempSource;
            matrix[tempIndex1] = tempTarget;
        }
    }
}

int main(int argc, char** argv)
{
    int* TwoDArr = nullptr;
    int N = 0;
    string input;
    cout &amp;lt;&amp;lt; &amp;quot;N = &amp;quot;;
    getline(cin, input);
    N = atoi(&amp;amp;input[0]);
    TwoDArr = new int[N*N];
    cout &amp;lt;&amp;lt; &amp;quot;What is the array?:\n&amp;quot;;
    for (int i = 0; i &amp;lt; N; i++)
    {
        getline(cin, input);
        memcpy(&amp;amp;TwoDArr[i*N], &amp;amp;(tokenizeStrings(input, &amp;quot; &amp;quot;, 0))[0], sizeof(int) * N);
    }
    cout &amp;lt;&amp;lt; &amp;quot;rotate? y/n: \n&amp;quot;;
    getline(cin, input);
    while (input == &amp;quot;y&amp;quot;)
    {
        rotateMatrix(TwoDArr, N);
    
        printMatrix(TwoDArr, N);
        cout &amp;lt;&amp;lt; &amp;quot;rotate? y/n: \n&amp;quot;;
        getline(cin, input);
    }
    //cleanup
    delete[] TwoDArr;
    return 0;
}
[/code]

Looking at the code above, the main loop runs for <code>N/2</code> times while the inner loop runs for <code>N - 2*N/2 + 1</code> times. Total time is then O(N/2*(N-N+1)) which is O(N). And the space requirement is O(1). I guess mission accomplished! :)

Here is a sample of the output:
<code>
N = 10
What is the array?:
1 2 3 4 5 6 7 8 9 0
0 9 8 7 6 5 4 3 2 1
1 3 5 7 9 2 4 6 8 0
0 8 6 4 2 9 7 5 3 1
0 1 2 3 4 5 4 3 2 1
9 8 7 6 5 6 7 8 9 0
1 1 1 1 1 1 1 1 1 1
2 2 2 2 2 2 2 2 2 2
9 8 7 6 7 8 9 8 7 6
0 0 0 0 0 0 0 0 0 0
rotate? y/n: 
y

0 9 2 1 9 0 0 1 0 1 
0 8 2 1 8 1 8 3 9 2 
0 7 2 1 7 2 6 5 8 3 
0 6 2 1 6 3 4 7 7 4 
0 7 2 1 5 4 2 9 6 5 
0 8 2 1 6 5 9 2 5 6 
0 9 2 1 7 4 7 4 4 7 
0 8 2 1 8 3 5 6 3 8 
0 7 2 1 9 2 3 8 2 9 
0 6 2 1 0 1 1 0 1 0 
rotate? y/n: 
y

0 0 0 0 0 0 0 0 0 0 
6 7 8 9 8 7 6 7 8 9 
2 2 2 2 2 2 2 2 2 2 
1 1 1 1 1 1 1 1 1 1 
0 9 8 7 6 5 6 7 8 9 
1 2 3 4 5 4 3 2 1 0 
1 3 5 7 9 2 4 6 8 0 
0 8 6 4 2 9 7 5 3 1 
1 2 3 4 5 6 7 8 9 0 
0 9 8 7 6 5 4 3 2 1 
rotate? y/n: 
y

0 1 0 1 1 0 1 2 6 0 
9 2 8 3 2 9 1 2 7 0 
8 3 6 5 3 8 1 2 8 0 
7 4 4 7 4 7 1 2 9 0 
6 5 2 9 5 6 1 2 8 0 
5 6 9 2 4 5 1 2 7 0 
4 7 7 4 3 6 1 2 6 0 
3 8 5 6 2 7 1 2 7 0 
2 9 3 8 1 8 1 2 8 0 
1 0 1 0 0 9 1 2 9 0 
rotate? y/n: 
y

1 2 3 4 5 6 7 8 9 0 
0 9 8 7 6 5 4 3 2 1 
1 3 5 7 9 2 4 6 8 0 
0 8 6 4 2 9 7 5 3 1 
0 1 2 3 4 5 4 3 2 1 
9 8 7 6 5 6 7 8 9 0 
1 1 1 1 1 1 1 1 1 1 
2 2 2 2 2 2 2 2 2 2 
9 8 7 6 7 8 9 8 7 6 
0 0 0 0 0 0 0 0 0 0 
rotate? y/n: n

Program exited with code 0.
</code>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>27</wp:post_id>
  <wp:post_date>2014-07-16 17:37:58</wp:post_date>
  <wp:post_date_gmt>2014-07-16 17:37:58</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>2d-matrix-rotator</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Autocomplete / Word Predictor / Simple Trie</title>
  <link>http://codeandbagels.wordpress.com/2014/07/22/autocomplete-word-predictor-simple-trie/</link>
  <pubDate>Tue, 22 Jul 2014 19:09:12 +0000</pubDate>
  <dc:creator>aamirsbored</dc:creator>
  <guid isPermaLink="false">http://codeandbagels.wordpress.com/2014/07/22/autocomplete-word-predictor-simple-trie/</guid>
  <description/>
  <content:encoded><![CDATA[<p>Decided to code up a Simple Trie for kicks. The code is still in the works, but can be accessed on git <a href="https://github.com/healthycola/SimpleWordPredictor/" target="_blank">here</a>.</p>
<p>I had never coded something of nature before, so this was a fun exercise in recursion. A description of a Trie was on <a href="http://en.wikipedia.org/wiki/Trie" target="_blank">wiki</a>, but I found the description described in <a href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/Trie/" target="_blank">this</a> site more comprehensible.</p>
<blockquote><p>A trie (from retrieval), is a multi-way tree structure useful for storing strings over an alphabet. It has been used to store large dictionaries of English (say) words in spelling-checking programs and in natural-language "understanding" programs.</p></blockquote>
<!--more-->


<p>For reference, the insert method was fairly simple. It included simply advancing a pointer to the current character of the word that we'd like to add by one. If the node for the next letter was in the tree then we would just go down the tree. Otherwise, we'd add it to the tree and continue until the end of the word, where we would have an end node.</p>
[code language="cpp"]
        void insert(string word, int charLocation)
        {
            //cout &lt;&lt; word &lt;&lt; &quot;\n&quot;;
            if (charLocation == word.length())
            {
                //last letter
                node* EndNode = new node('&#092;&#048;');
                children.push_back(EndNode);
                return;
            }
            else
            {
                vector&lt;node*&gt;::iterator child;
                for (child = children.begin(); child != children.end(); child++)
                {
                    if ((*child)-&gt;val == word[charLocation])
                        break;
                }
                
                if (child == children.end())
                {
                    node* middleNode = new node(word[charLocation]);
                    children.push_back(middleNode);
                    totalNodes++;
                    return middleNode-&gt;insert(word, charLocation + 1);
                }
                else
                {
                    return (*child)-&gt;insert(word, charLocation + 1);
                }
            }
        }
[/code]
<p>Retrieval was a bit more of a challenge. Given a small input string, the challenge was to find out all the possible words. This, I'm sure can be implemented in a better way than I have. What I do is, basically traverse the tree until I get to the last character of the input string. Then I want to retrieve all the words that branch from that character. It sounds okay in theory, but I think my implementation can be improved.</p>
<p>[code language="cpp"]string retrieve(string input, int charLocation)
        {
            string output = &quot;&quot;;
            if (charLocation &lt;= input.length() - 1)
            {
                //Get to correct branch
                vector&lt;node*&gt;::iterator child;
                for (child = children.begin(); child != children.end(); child++)
                {
                    if ((*child)-&gt;val == input[charLocation])
                        break;
                }
                if (child == children.end())
                    return &quot;&quot;;
                else
                {
                    return (*child)-&gt;retrieve(input, charLocation + 1);
                }
            }
            else if (val == '&#092;&#048;')
            {
                return input + &quot;\n&quot;;
            }
            else if (charLocation == input.length())
            {
                for (vector&lt;node*&gt;::iterator child = children.begin(); child != children.end(); child++)
                {
                    output += (*child)-&gt;retrieve(input, charLocation + 1);
                }
                return output;
            }
            else
            {
                //All the subsequent strings will be recommendations
                for (vector&lt;node*&gt;::iterator child = children.begin(); child != children.end(); child++)
                {
                    output += (*child)-&gt;retrieve(input + val, charLocation + 1);
                }
                return output;
            }
        }
[/code]</p>
<p>A sample run of the program for a list of 200 words (which is up on the Git page) is shown below.<br />
[code]Enter the filePath: wordList.txt
Trie was populated. Total notes created were 613
Enter a stream and we will tell you what words are possible. Enter quit to exit.
ga
Next Word: lo
Next Word: li
little
live
line
light
life
list
Next Word: ab
above
Next Word: tr
try
tree
Next Word: quit
Program ended with exit code: 0
[/code]</p>
<p>All in all this was a fun exercise. I think I'll include weights to the words so that they are sorted in a smarter order than this. Still a WIP!</p>
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>35</wp:post_id>
  <wp:post_date>2014-07-22 19:09:12</wp:post_date>
  <wp:post_date_gmt>2014-07-22 19:09:12</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>autocomplete-word-predictor-simple-trie</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="trie"><![CDATA[Trie]]></category>
  <category domain="category" nicename="uncategorized"><![CDATA[Uncategorized]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Squatting!</title>
  <link>http://codeandbagels.wordpress.com/2014/07/22/squatting/</link>
  <pubDate>Tue, 22 Jul 2014 19:21:08 +0000</pubDate>
  <dc:creator>aamirsbored</dc:creator>
  <guid isPermaLink="false">http://codeandbagels.wordpress.com/?p=40</guid>
  <description/>
  <content:encoded><![CDATA[<p>I've been doing the <a href="http://stronglifts.com/5x5/" target="_blank">SL 5x5</a> for a few weeks now and I'm really enjoying it (especially since it's Ramadan right now). </p>
<p>I've struggled with getting my squats perfect and often feel like I'm straining my lower back when performing them, which can be very dangerous in the long run. That being said, today I found a really great video that shows how to do lower bar squats safely.<br />
[youtube https://www.youtube.com/watch?v=RMFHgVN_pcg&amp;w=560&amp;h=315]</p>
<p>As of today, my weights are as follows (all 5 rep in lbs):<br />
Squats: 155<br />
Bench: 155<br />
Barbell Row: 115<br />
Overhead Press: 80<br />
DeadLift: 125</p>
<p>I've been feeling stronger too, so I really hope this regime is a good path for me.</p>
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>40</wp:post_id>
  <wp:post_date>2014-07-22 19:21:08</wp:post_date>
  <wp:post_date_gmt>2014-07-22 19:21:08</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>squatting</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="fitness"><![CDATA[fitness]]></category>
  <category domain="category" nicename="powerlifting"><![CDATA[powerlifting]]></category>
  <category domain="category" nicename="weightlifting"><![CDATA[weightlifting]]></category>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Huffman Encoding Implementation</title>
  <link>http://codeandbagels.wordpress.com/2014/07/24/huffman-encoding-implementation/</link>
  <pubDate>Thu, 24 Jul 2014 09:19:15 +0000</pubDate>
  <dc:creator>aamirsbored</dc:creator>
  <guid isPermaLink="false">http://codeandbagels.wordpress.com/?p=45</guid>
  <description/>
  <content:encoded><![CDATA[<p>There was a fun little challenge on Reddit that I decided to partake in. I'm going to copy the challenge from <a href="http://www.reddit.com/r/dailyprogrammer/comments/2b21mp/7182014_challenge_171_hard_intergalatic_bitstream/" target="_blank">there</a> for completion.</p>
<blockquote><p> It is 2114. We have colonized the Galaxy. To communicate we send 140 character max messages using [A-Z0-9 ]. The technology to do this requires faster than light pulses to beam the messages to relay stations.<br />
Your challenge is to implement the compression for these messages. The design is very open and the solutions will vary.<br />
Your goals:<br />
Compact 140 Bytes down to a stream of bits to send and then decompact the message and verify 100% data contained.<br />
The goal is bit reduction. 140 bytes or less at 8 bits per byte so thats 1120 bits max. If you take a message of 140 bytes and compress it to 900 bits you have 220 less bits for 20% reduction.</p></blockquote>

I decided to take this as an excuse to implement the <a href="http://en.wikipedia.org/wiki/Huffman_coding" target="_blank">Huffman Encoding</a> technique that we learned about in school. 

This was the first time I had a chance to work with the map data structure in C++, so that was fun. Essentially, what I did was supply the program with a sample text from which it could extract frequency data of each of the characters. I realized after that I could have just wiki'd this, since frequency data for letters is <a href="http://en.wikipedia.org/wiki/Letter_frequency" target="_blank">available</a> online. Ah well...
<!--more-->


Once I generated the frequency list, I went ahead and created the tree using nodes. Each node contain a few things - frequency of that particular character (or parent), the value of the character if it was a leaf node, and the pointers to the left and right nodes (null upon initialization, and it remains null if they are leaf nodes).

[code language="cpp"]
void generateTree()
    {
        vector&lt;HuffEncNode*&gt; TreeNodes;
        for (map&lt;char, int&gt;::iterator it = frequencyChart.begin(); it != frequencyChart.end(); it++)
        {
            HuffEncNode* leafNode = new HuffEncNode((it)-&gt;first, (it)-&gt;second);
            TreeNodes.push_back(leafNode);
        }
        sort(TreeNodes.begin(), TreeNodes.end(), HuffEncNode::compare);
        while (TreeNodes.size() &gt; 1)
        {
            //Pop last two elements
            HuffEncNode* RightNode = TreeNodes.back();
            TreeNodes.pop_back();
            HuffEncNode* LeftNode = TreeNodes.back();
            TreeNodes.pop_back();
            
            HuffEncNode* parentNode = new HuffEncNode(RightNode-&gt;frequency + LeftNode-&gt;frequency, LeftNode, RightNode);
            TreeNodes.push_back(parentNode);
            sort(TreeNodes.begin(), TreeNodes.end(), HuffEncNode::compare);
        }
        parentNode = TreeNodes.front();
        
        //Generate the encoding map
        parentNode-&gt;generateCodes(&quot;&quot;, &amp;encodedMap);
    }
[/code]

The algorithm itself is described on the wikipedia page for Huffman encoding. The last bit of the code which says Generate the encoding map, essentially traverses down the tree and saves the codes for each character in a map for easier access during the encoding process. 

During the decoding process, the program would simply traverse down the tree based on the bit (1 or 0) until it hit a character. That's the beauty of Huffman Encoding.

[code language="cpp"]
char deCode(string input, int* characterLocation)
        {
            if (leftNode == NULL &amp;&amp; rightNode == NULL)
            {
                //leaf node
                return ASCIIVal;
            }
            
            if (input[*characterLocation] == '0')
            {
                //go into the right node
                (*characterLocation)++;
                return rightNode-&gt;deCode(input, characterLocation);
            }
            else
            {
                //go into the left node
                (*characterLocation)++;
                return leftNode-&gt;deCode(input, characterLocation);
            }
        }
[/code]

The sample that the challenge wanted us to use was as follows:
<ol>
	<li>REMEMBER TO DRINK YOUR OVALTINE</li>
	<li>GIANTS BEAT DODGERS 10 TO 9 AND PLAY TOMORROW AT 1300</li>
	<li>SPACE THE FINAL FRONTIER THESE ARE THE VOYAGES OF THE BIT STREAM DAILY PROGRAMMER TO SEEK OUT NEW COMPRESSION</li>
</ol>
Using the test set above to train the Huffman encoding would defeat the purpose of the challenge, but I figured it would be a good benchmark to use. So developing the encoding tree with the test set above resulted in this:
<pre>
<em><strong>The coding is as follows:</strong></em>
  - 11
0 - 101010
1 - 0001011
2 - 00011111111111110
3 - 000111110
4 - 000111111111110
5 - 00011111111110
6 - 000111111110
7 - 00011111110
8 - 0001111110
9 - 00011110
A - 0110
B - 011110
C - 101011
D - 10100
E - 100
F - 011111
G - 000011
H - 000010
I - 01001
J - 0001111111110
K - 0001010
L - 000000
M - 01110
N - 01000
O - 0011
P - 000001
Q - 0001111111111110
R - 0101
S - 1011
T - 0010
U - 0001000
V - 0001001
W - 0001110
X - 000111111111111110
Y - 000110
Z - 000111111111111111

<em><strong>Results are as follows:</strong></em>
Read Message of 31 Bytes.
Compressing 248 Bits into 134 Bits. (45.9677% compression)
Sending Message
Decompressing Message into 31 Bytes.
Message Matches!

Read Message of 53 Bytes.
Compressing 424 Bits into 233 Bits. (45.0472% compression)
Sending Message
Decompressing Message into 53 Bytes.
Message Matches!

Read Message of 109 Bytes.
Compressing 872 Bits into 449 Bits. (48.5092% compression)
Sending Message
Decompressing Message into 109 Bytes.
Message Matches!
Program ended with exit code: 0
</pre>

Training the Huffman Tree with an ebook I found on <a href="http://gutenberg.org" target="_blank">Project Gutenberg</a> worked fairly well for me. Here are the results:

<pre>
<em><strong>The coding is as follows:</strong></em>
  - 000
0 - 111010101
1 - 11101011
2 - 111010001
3 - 111010100
4 - 0100011101
5 - 0100011111
6 - 1110100111
7 - 1110100100
8 - 1110100101
9 - 01000111000
A - 0101
B - 100111
C - 10010
D - 11100
E - 110
F - 001101
G - 010000
H - 1111
I - 0111
J - 0100011110
K - 01000110
L - 01001
M - 001111
N - 1000
O - 0110
P - 001110
Q - 1110100110
R - 1011
S - 1010
T - 0010
U - 001100
V - 0100010
W - 100110
X - 111010000
Y - 111011
Z - 01000111001

<em><strong>Results are as follows:</strong></em>
Read Message of 31 Bytes.
Compressing 248 Bits into 135 Bits. (45.5645% compression)
Sending Message
Decompressing Message into 31 Bytes.
Message Matches!

Read Message of 53 Bytes.
Compressing 424 Bits into 253 Bits. (40.3302% compression)
Sending Message
Decompressing Message into 53 Bytes.
Message Matches!

Read Message of 109 Bytes.
Compressing 872 Bits into 449 Bits. (48.5092% compression)
Sending Message
Decompressing Message into 109 Bytes.
Message Matches!
</pre>

Not bad! The bench mark gives 46%, 45% and 48.5%. On the other side, I get compression rates of 45.6%, 40.33% and 48.5%. Not bad! Seems like the main issue with the ebook text I used was with the numbers. 

Anyway, I'm gonna head to sleep, but that was fun! Gotta refine the project files up. <del datetime="2014-07-24T21:09:48+00:00">I'll do that later</del>. <ins datetime="2014-07-24T21:09:48+00:00"><a href="https://github.com/healthycola/HuffmanEncode" target="_blank">They're up now</a>.</ins>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>45</wp:post_id>
  <wp:post_date>2014-07-24 09:19:15</wp:post_date>
  <wp:post_date_gmt>2014-07-24 09:19:15</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>huffman-encoding-implementation</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="algorithm"><![CDATA[algorithm]]></category>
  <category domain="post_tag" nicename="c"><![CDATA[C++]]></category>
  <category domain="category" nicename="c"><![CDATA[C++]]></category>
  <category domain="post_tag" nicename="encoding"><![CDATA[encoding]]></category>
  <category domain="post_tag" nicename="huffman"><![CDATA[huffman]]></category>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_facebook</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_google_plus</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_twitter</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_linkedin</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_tumblr</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_wpas_skip_path</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_published</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_rest_api_client_id</wp:meta_key>
    <wp:meta_value><![CDATA[-1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
</item>
  </channel>
</rss>
